import 'dart:async';import 'dart:math';import 'package:flutter_bloc/flutter_bloc.dart';import 'package:geolocator/geolocator.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:samoilenko_maps_app/features/stations/bloc/stations_bloc/stations_cubit_state.dart';import '../../../../common/services/logger.dart';import '../../repositories/stations_repository.dart';import '../../services/location_service.dart';class StationsCubit extends Cubit<StationsCubitState> {  final StationsRepository stationsRepository;  final GeolocationService locationsService;  StationsCubit({    required this.stationsRepository,    required this.locationsService,  }) : super(          const StationsCubitState.initial(),        );  Future<void> fetchStations() async {    emit(const StationsCubitState.loading());    try {      final stations = await stationsRepository.fetchStations();      final bool hasGeolocation = await locationsService.hasGeoLocation();      final currentLocation = await locationsService.loadCurrentLocation();      await locationsService.loadCurrentLocation();      if (currentLocation == null || !hasGeolocation) {        try {          await locationsService.checkAndRequestLocationAccess();          await locationsService.loadCurrentLocation();        } catch (e) {          log.fine('Permission Denied $e');        }      } else {        try {          await locationsService.loadCurrentLocation();        } catch (e) {          log.fine('Permission Denied $e');        }      }      final permissionGranted = Geolocator.checkPermission();      final myLocation = currentLocation;      final permissionStatus = await permissionGranted;      if (permissionStatus == LocationPermission.deniedForever) {        emit(const StationsCubitState.permissionDenied());      }      emit(        StationsCubitState.loaded(          stationsInfo: stations,          myLocation: myLocation != null ? LatLng(myLocation.x, myLocation.y) : null,        ),      );    } catch (e) {      emit(StationsCubitState.error(message: e.toString()));    }  }  Future<Point<double>?> getMyLocation() async {    final currentLocation = await locationsService.loadCurrentLocation();    return currentLocation;  }}
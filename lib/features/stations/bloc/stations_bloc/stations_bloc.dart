import 'dart:async';import 'dart:math';import 'package:flutter_bloc/flutter_bloc.dart';import 'package:geolocator/geolocator.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:samoilenko_maps_app/features/stations/bloc/stations_bloc/stations_event.dart';import 'package:samoilenko_maps_app/features/stations/bloc/stations_bloc/stations_state.dart';import '../../../../common/services/logger.dart';import '../../models/station.dart';import '../../repositories/stations_repository.dart';import '../../services/location_service.dart';class StationsBloc extends Bloc<StationsEvent, StationsState> {  final StationsRepository stationsRepository;  final GeolocationService locationsService;  StationsBloc({    required this.stationsRepository,    required this.locationsService,  }) : super(          const StationsInitial(stationsInfo: []),        ) {    on<FetchStationsEvent>(_onFetchStations);    on<ItemTappedEvent>(_onItemTapped);  }  Future<void> _onFetchStations(    FetchStationsEvent event,    Emitter<StationsState> emit,  ) async {    emit(const StationsLoading(stationsInfo: []));    try {      final results = await Future.wait([        stationsRepository.fetchStations(),        locationsService.hasGeoLocation(),        locationsService.loadCurrentLocation(),      ]);      final stations = results[0]! as List<Station>;      final bool hasGeolocation = results[1]! as bool;      final Point<double>? currentLocation = results[2] as Point<double>?;      if (currentLocation == null || !hasGeolocation) {        try {          await locationsService.checkAndRequestLocationAccess();        } catch (e) {          log.fine('Permission Denied $e');        }      }      final locationPermission = Geolocator.checkPermission();      final myLocation = currentLocation;      final permissionStatus = await locationPermission;      if (permissionStatus == LocationPermission.deniedForever) {        emit(const StationsPermissionDenied(stationsInfo: []));      }      emit(        StationsLoaded(          stationsInfo: stations,          myLocation: myLocation != null ? LatLng(myLocation.x, myLocation.y) : null,        ),      );    } catch (e) {      emit(StationsError(message: e.toString(), stationsInfo: const []));    }  }  Future<Point<double>?> getMyLocation() async {    final currentLocation = await locationsService.loadCurrentLocation();    return currentLocation;  }  Future<void> _onItemTapped(    ItemTappedEvent event,    Emitter<StationsState> emit,  ) async {    try {      emit(        SelectedSearchStation(stationsInfo: state.stationsInfo, highlightedLocation: event.highlightedLocation),      );    } catch (e) {      emit(StationsError(message: e.toString(), stationsInfo: const []));    }  }}
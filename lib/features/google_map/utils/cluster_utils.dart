import 'dart:async';import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';import 'package:geolocator/geolocator.dart';import 'package:google_maps_cluster_manager/google_maps_cluster_manager.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:samoilenko_maps_app/features/stations/models/map_marker/map_marker.dart';import '../../../generated/assets.gen.dart';import '../../google_map/widgets/map_status_text_widget.dart';import '../../stations/bloc/stations_bloc/stations_cubit.dart';import '../../stations/models/station.dart';import '../../stations/widgets/station_point_card.dart';import '../../theme/theme_info.dart';enum StatusValues { busy, available, offline, userLocation }List<CustomMapMarker> makeListOfCustomMapMarkers({required List<Station> stationsInfo}) {  final List<CustomMapMarker> places = [];  for (final i in stationsInfo) {    places.add(      CustomMapMarker(        latLng: LatLng(i.latitude!, i.longitude!),        name: i.stationId,        status: i.status,        connectors: i.connectors,      ),    );  }  return places;}Future<Marker> Function(BuildContext, Cluster<CustomMapMarker>) get markerBuilder => (context, cluster) async {      final double fullWidth = MediaQuery.of(context).size.width;      return Marker(        markerId: MarkerId(cluster.getId()),        position: cluster.location,        onTap: () async {          final myLocation = await context.read<StationsCubit>().getMyLocation();          if (context.mounted) {            if (cluster.items.length == 1) {              final items = cluster.items.toList()[0];              final distanceInKilometers = myLocation != null                  ? Geolocator.distanceBetween(                        items.latLng.latitude,                        items.latLng.longitude,                        myLocation.x,                        myLocation.y,                      ) /                      1000                  : null;              showModalBottomSheet<void>(                context: context,                backgroundColor: Colors.transparent,                barrierColor: Colors.transparent,                elevation: 0,                isScrollControlled: true,                shape: const RoundedRectangleBorder(                  borderRadius: BorderRadius.vertical(top: Radius.circular(16.0)),                ),                builder: (BuildContext context) {                  return StationPointCard(                    fullWidth: fullWidth,                    items: items,                    currentContext: context,                    distanceInKilometers: distanceInKilometers,                  );                },              );            }          }        },        icon: cluster.isMultiple            ? await _getClusterMarkerBitmap(                text: cluster.isMultiple ? cluster.count.toString() : null,                pinAtts: cluster.items,              )            : await _getMarkerBitmap(                text: cluster.isMultiple ? cluster.count.toString() : null,                pinAtts: cluster.items,              ),      );    };Future<BitmapDescriptor> _getMarkerBitmap({  String? text,  required Iterable<CustomMapMarker> pinAtts,}) async {  var img = Assets.images.pinGreen.path;  for (final i in pinAtts) {    if (i.myLocation != null) {      img = getStationPinImage(StatusValues.userLocation);    } else {      img = getStationPinImage(i.status);    }  }  return await BitmapDescriptor.fromAssetImage(      const ImageConfiguration(        devicePixelRatio: 3.2,      ),      img);}Future<BitmapDescriptor> _getClusterMarkerBitmap({  String? text,  required Iterable<CustomMapMarker> pinAtts,}) async {  return await BitmapDescriptor.fromAssetImage(    const ImageConfiguration(devicePixelRatio: 3.2),    Assets.images.icMap.path,  );}String getStationPinImage(StatusValues? status) {  switch (status) {    case StatusValues.available:      return Assets.images.pinGreen.path;    case StatusValues.busy:      return Assets.images.pinYellow.path;    case StatusValues.offline:      return Assets.images.pinRed.path;    case StatusValues.userLocation:      return Assets.images.icMap.path;    default:      return Assets.images.pinBlack.path;  }}String getStationStatusText(StatusValues? status) {  switch (status) {    case StatusValues.available:      return 'Open';    case StatusValues.busy:      return 'Busy';    default:      return 'Close';  }}String getConnectorStatusText(String? statusType) {  String val = 'Combo Css';  if (statusType == 'TYPE_2_PLUG') {    val = 'Type2 (AC)';  }  if (statusType == 'TYPE_1') {    val = 'CHAdeMO';  }  if (statusType == 'TYPE_2_PLUG') {    val = 'Type2 (AC)';  }  return val;}Widget getStationStatusWidget(StatusValues? status) {  switch (status) {    case StatusValues.available:      return const MapStatusTextWidget(        statusText: 'Open',        bgColor: greenAccent,      );    case StatusValues.busy:      return const MapStatusTextWidget(        statusText: 'Busy',        bgColor: yellowColor,      );    default:      return const MapStatusTextWidget(        statusText: 'Close',        bgColor: redColor,      );  }}